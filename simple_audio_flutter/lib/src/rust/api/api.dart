// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `into`, `into`, `into`

// Rust type: RustOpaqueMoi<Player>
abstract class Player implements RustOpaqueInterface {}

@freezed
sealed class Error with _$Error {
  const Error._();

  /// An error occurred when trying to fetch more bytes for
  /// a network stream.
  const factory Error.networkStream(
    String field0,
  ) = Error_NetworkStream;

  /// An error occurred when decoding the file.
  const factory Error.decode(
    String field0,
  ) = Error_Decode;

  /// An error occurred when trying to open a file.
  const factory Error.open(
    String field0,
  ) = Error_Open;

  /// An error occurred when trying to preload a file.
  const factory Error.preload(
    String field0,
  ) = Error_Preload;
}

enum PlaybackState {
  /// The player is currently playing the file.
  play,

  /// The player is currently paused and there is no output.
  pause,

  /// The player has finished playing the file.
  done,

  /// The player was stopped
  stop,

  /// The player has automatically started playing the preloaded file.
  preloadPlayed,
  ;
}

class PlayerWrapper {
  final Player internal;

  const PlayerWrapper({
    required this.internal,
  });

  Future<void> clearPreload() =>
      RustLib.instance.api.crateApiApiPlayerWrapperClearPreload(
        that: this,
      );

  static Future<void> dispose() =>
      RustLib.instance.api.crateApiApiPlayerWrapperDispose();

  static Stream<Error> errorStream() =>
      RustLib.instance.api.crateApiApiPlayerWrapperErrorStream();

  Future<bool> isLooping() =>
      RustLib.instance.api.crateApiApiPlayerWrapperIsLooping(
        that: this,
      );

  Future<bool> isNormalizing() =>
      RustLib.instance.api.crateApiApiPlayerWrapperIsNormalizing(
        that: this,
      );

  /// Returns `true` if there is a file preloaded for playback.
  Future<bool> isPreloaded() =>
      RustLib.instance.api.crateApiApiPlayerWrapperIsPreloaded(
        that: this,
      );

  Future<void> loopPlayback({required bool shouldLoop}) => RustLib.instance.api
      .crateApiApiPlayerWrapperLoopPlayback(that: this, shouldLoop: shouldLoop);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<PlayerWrapper> newInstance() =>
      RustLib.instance.api.crateApiApiPlayerWrapperNew();

  Future<void> normalizeVolume({required bool shouldNormalize}) =>
      RustLib.instance.api.crateApiApiPlayerWrapperNormalizeVolume(
          that: this, shouldNormalize: shouldNormalize);

  Future<void> open({required String path, required bool autoplay}) => RustLib
      .instance.api
      .crateApiApiPlayerWrapperOpen(that: this, path: path, autoplay: autoplay);

  Future<void> pause() => RustLib.instance.api.crateApiApiPlayerWrapperPause(
        that: this,
      );

  Future<void> play() => RustLib.instance.api.crateApiApiPlayerWrapperPlay(
        that: this,
      );

  Future<void> playPreload() =>
      RustLib.instance.api.crateApiApiPlayerWrapperPlayPreload(
        that: this,
      );

  static Stream<Duration> playbackStartedStream() =>
      RustLib.instance.api.crateApiApiPlayerWrapperPlaybackStartedStream();

  Future<PlaybackState> playbackState() =>
      RustLib.instance.api.crateApiApiPlayerWrapperPlaybackState(
        that: this,
      );

  static Stream<PlaybackState> playbackStateStream() =>
      RustLib.instance.api.crateApiApiPlayerWrapperPlaybackStateStream();

  Future<void> preload({required String path}) => RustLib.instance.api
      .crateApiApiPlayerWrapperPreload(that: this, path: path);

  Future<ProgressState> progress() =>
      RustLib.instance.api.crateApiApiPlayerWrapperProgress(
        that: this,
      );

  static Stream<ProgressState> progressStateStream() =>
      RustLib.instance.api.crateApiApiPlayerWrapperProgressStateStream();

  Future<void> seek({required Duration position}) => RustLib.instance.api
      .crateApiApiPlayerWrapperSeek(that: this, position: position);

  Future<void> setVolume({required double volume}) => RustLib.instance.api
      .crateApiApiPlayerWrapperSetVolume(that: this, volume: volume);

  Future<void> stop() => RustLib.instance.api.crateApiApiPlayerWrapperStop(
        that: this,
      );

  Future<double> volume() =>
      RustLib.instance.api.crateApiApiPlayerWrapperVolume(
        that: this,
      );

  @override
  int get hashCode => internal.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PlayerWrapper &&
          runtimeType == other.runtimeType &&
          internal == other.internal;
}

class ProgressState {
  /// The position of the player.
  final Duration position;

  /// The duration of the file that is being played.
  final Duration duration;

  const ProgressState({
    required this.position,
    required this.duration,
  });

  @override
  int get hashCode => position.hashCode ^ duration.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProgressState &&
          runtimeType == other.runtimeType &&
          position == other.position &&
          duration == other.duration;
}
